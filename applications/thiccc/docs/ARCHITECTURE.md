# iOS App Architecture - Swift â†” Rust Bridge

This document explains how the Thiccc iOS app bridges Swift UI with Rust business logic.

---

## SWIFT â†” RUST BRIDGE ARCHITECTURE

The iOS app acts as a "thin shell" around a Rust core, with **all business logic in Rust** and **only UI in Swift**.

---

## ðŸ“‹ Table of Contents

1. [Why This Architecture?](#why-this-architecture)
2. [How It Works (Step by Step)](#how-it-works-step-by-step)
3. [The Bridge Metaphor](#the-bridge-metaphor)
4. [Data Flow Example](#data-flow-example)
5. [Automatic Build Process](#automatic-build-process)
6. [File Structure](#file-structure)
7. [Key Files Explained](#key-files-explained)

---

## Why This Architecture?

### The Problem

Your app is written in **TWO languages**:

- **Swift** (iOS UI layer) â† SwiftUI views, navigation, presentation
- **Rust** (Business logic) â† Workout management, timer, calculations, database

**Problem:** Swift can't directly talk to Rust. They have different:
- Memory models (ARC vs ownership)
- Function calling conventions
- Type systems
- Data representations

### The Solution

We use **UniFFI** - Mozilla's tool that **automatically generates** the "translation layer" between Swift and Rust.

**Key Benefits:**
- âœ… **Type-safe**: Compiler catches mistakes across the FFI boundary
- âœ… **Automatic**: No manual pointer management or marshalling
- âœ… **Single source of truth**: Define interface once in `.udl` file
- âœ… **Memory safe**: Automatic reference counting across languages

---

## How It Works (Step by Step)

### 1ï¸âƒ£ **Write Rust Code**

**File:** `app/shared/src/lib.rs`

This contains ALL your business logic:
- Workout creation and management
- Exercise and set tracking
- Timer logic
- Plate calculator
- Database operations

```rust
// Example from lib.rs
pub fn process_event(msg: &[u8]) -> Result<Vec<u8>, CoreError> {
    // Deserialize event from Swift
    let event: Event = serde_json::from_slice(msg)?;
    
    // Update app state
    let updated_state = match event {
        Event::CreateWorkout { name } => {
            // Business logic here
        }
        // ... more events
    };
    
    // Serialize state back to Swift
    Ok(serde_json::to_vec(&updated_state)?)
}
```

**Key Point:** This code has ZERO knowledge of iOS. It's pure logic.

---

### 2ï¸âƒ£ **Define the Interface (shared.udl)**

**File:** `app/shared/src/shared.udl`

This is like a "menu" of functions Swift can call:

```udl
namespace shared {
    // These functions will be available in Swift
    bytes process_event([ByRef] bytes msg);
    bytes view();
    bytes handle_response(u32 id, [ByRef] bytes res);
};
```

**What this means:**
- `namespace shared` â†’ Swift will `import SharedCore`
- `bytes process_event(...)` â†’ Swift can call `processEvent(msg:)`
- `[ByRef]` â†’ Pass by reference (efficient for large data)

**This is the single source of truth for the FFI boundary.**

---

### 3ï¸âƒ£ **UniFFI Auto-Generates Swift Code**

When you build:

1. **Build script** (`build.rs`) runs
2. **Reads** `shared.udl`
3. **Generates** Swift bindings:
   - `shared.swift` - Swift functions that call Rust
   - `sharedFFI.h` - C header (FFI uses C ABI)
   - `sharedFFI.modulemap` - Makes it importable as module

**Output location:** `app/ios/thiccc/Thiccc/Generated/`

**Swift imports this as:** `import SharedCore`

**Example Generated Code:**
```swift
// Generated by UniFFI - you never write this!
public func processEvent(msg: [UInt8]) throws -> [UInt8] {
    // Complex FFI code that calls Rust
    // Handles memory management, error conversion, etc.
}
```

---

### 4ï¸âƒ£ **CoreUniffi.swift Uses Those Generated Functions**

**File:** `app/ios/thiccc/Thiccc/CoreUniffi.swift`

This is YOUR code that uses the generated functions:

```swift
import SharedCore  // The generated module

class RustCoreUniffi: ObservableObject {
    func dispatch(_ event: Event) {
        // Encode to bytes
        let eventBytes = [UInt8](try JSONEncoder().encode(event))
        
        // Call Rust! (looks like normal Swift, but calls across FFI)
        let viewBytes = try processEvent(msg: eventBytes)
        
        // Decode response
        self.viewModel = try JSONDecoder().decode(ViewModel.self, from: Data(viewBytes))
    }
}
```

**Key observations:**
- Line 28: `let viewData = try view()` â† Calling Rust!
- Line 53: `let viewBytes = try processEvent(msg: eventBytes)` â† Calling Rust!
- These **look** like normal Swift functions
- But they're actually **crossing the FFI boundary** into Rust

---

## The Bridge Metaphor

Think of `CoreUniffi.swift` as a **translator at the United Nations**:

```
Swift (English) â—„â”€â”€â–º CoreUniffi.swift (Translator) â—„â”€â”€â–º Rust (French)
```

**The translator does:**
1. Takes Swift types â†’ Converts to bytes
2. Calls Rust function (via UniFFI)
3. Takes bytes back â†’ Converts to Swift types
4. Updates UI via `@Published` properties

---

## Data Flow Example

Let's trace what happens when you tap **"Create Workout"** in the UI:

### 1. User Action (SwiftUI)
```swift
Button("Create Workout") {
    core.dispatch(.createWorkout(name: "Leg Day"))
}
```

### 2. Swift Bridge (CoreUniffi.swift)
```swift
func dispatch(_ event: Event) {
    // Convert Swift enum â†’ JSON â†’ bytes
    let eventJson = try JSONEncoder().encode(event)
    let eventBytes = [UInt8](eventJson)
    
    // Cross FFI boundary into Rust
    let viewBytes = try processEvent(msg: eventBytes)
    
    // Convert bytes â†’ JSON â†’ Swift struct
    self.viewModel = try JSONDecoder().decode(ViewModel.self, from: Data(viewBytes))
}
```

### 3. Rust Core (lib.rs)
```rust
pub fn process_event(msg: &[u8]) -> Result<Vec<u8>, CoreError> {
    let event: Event = serde_json::from_slice(msg)?;
    
    match event {
        Event::CreateWorkout { name } => {
            // Create workout
            let workout = Workout::new(name);
            // Update state
            app.model.workout = Some(workout);
            // Generate view model
            let view_model = app.view();
            // Return as bytes
            Ok(serde_json::to_vec(&view_model)?)
        }
    }
}
```

### 4. UI Update (Automatic!)
```swift
// Because viewModel is @Published
self.viewModel = ... // Triggers SwiftUI refresh
```

**Total data journey:**
```
SwiftUI â†’ Swift Event â†’ JSON bytes â†’ Rust â†’ Updated state â†’ JSON bytes â†’ Swift ViewModel â†’ SwiftUI
```

---

## Automatic Build Process

After initial setup (`./scripts/setup-mac.sh`), Xcode has a **pre-build script** that:

### What Happens on Every Build

```bash
# 1. Check if Rust code changed
if [[ Rust files modified ]]; then
    # 2. Rebuild Rust library
    cargo build --release --target aarch64-apple-ios-sim
    
    # 3. Regenerate Swift bindings
    uniffi-bindgen generate shared.udl --language swift
    
    # 4. Copy to Generated/ folder
fi

# 5. Xcode links everything together
```

### What This Means for You

**Just hit âŒ˜R in Xcode!**

- Changed Rust code? â†’ Automatically rebuilds
- Changed Swift code? â†’ Automatically rebuilds
- Changed `.udl` interface? â†’ Regenerates bindings

**You never manually run build scripts during development.**

---

## File Structure

```
app/
â”œâ”€â”€ shared/                           # Rust Core (Business Logic)
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs                    # Main Rust code + Crux app
â”‚   â”‚   â”œâ”€â”€ models.rs                 # Data models (Workout, Exercise, etc.)
â”‚   â”‚   â”œâ”€â”€ database.rs               # SQLite operations
â”‚   â”‚   â”œâ”€â”€ shared.udl                # â­ UniFFI interface definition
â”‚   â”‚   â””â”€â”€ bin/
â”‚   â”‚       â””â”€â”€ uniffi-bindgen.rs     # CLI tool for binding generation
â”‚   â”œâ”€â”€ build.rs                      # Build script (generates scaffolding)
â”‚   â”œâ”€â”€ uniffi.toml                   # UniFFI configuration
â”‚   â””â”€â”€ Cargo.toml                    # Rust dependencies
â”‚
â””â”€â”€ ios/                              # Swift Shell (UI Only)
    â”œâ”€â”€ project.yml                   # XcodeGen spec (generates .xcodeproj)
    â”œâ”€â”€ ARCHITECTURE.md               # â­ This file
    â”œâ”€â”€ README.md                     # Setup instructions
    â””â”€â”€ thiccc/Thiccc/
        â”œâ”€â”€ ThicccApp.swift           # App entry point
        â”œâ”€â”€ CoreUniffi.swift          # â­ Swift â†” Rust bridge
        â”œâ”€â”€ Views/                    # SwiftUI views
        â”‚   â”œâ”€â”€ WorkoutView.swift
        â”‚   â”œâ”€â”€ HistoryView.swift
        â”‚   â””â”€â”€ ...
        â”œâ”€â”€ Models/                   # Swift models (mirror Rust)
        â”œâ”€â”€ Assets.xcassets/          # App icon, colors
        â””â”€â”€ Generated/                # â­ Auto-generated (don't edit!)
            â”œâ”€â”€ shared.swift          # Generated Swift API
            â”œâ”€â”€ sharedFFI.h           # Generated C header
            â””â”€â”€ sharedFFI.modulemap   # Module definition
```

---

## Key Files Explained

### `shared.udl` - The Contract

```udl
// This defines what Swift can call
namespace shared {
    bytes process_event([ByRef] bytes msg);  // Send events
    bytes view();                             // Get current state
    bytes handle_response(u32 id, [ByRef] bytes res);  // Handle effects
};
```

**When to modify:**
- Adding new Rust functions that Swift needs to call
- Changing function signatures
- Exposing new types

**After modifying:** Build runs automatically, bindings regenerate

---

### `CoreUniffi.swift` - The Bridge

**Responsibilities:**
1. **Import generated module:** `import SharedCore`
2. **Wrap Rust calls** in Swift-friendly API
3. **Manage `@Published` state** for SwiftUI
4. **Handle side effects** (database, timers)

**What it does NOT do:**
- âŒ Business logic (that's in Rust)
- âŒ Database queries (that's in Rust)
- âŒ Calculations (that's in Rust)

**It ONLY:**
- âœ… Calls Rust
- âœ… Updates SwiftUI
- âœ… Coordinates Swift-side effects (if needed)

---

### `build.rs` - The Build Script

Runs **before** Rust compilation:

```rust
fn main() {
    // Generate Rust scaffolding from shared.udl
    uniffi::generate_scaffolding("./src/shared.udl").unwrap();
}
```

This creates the Rust side of the FFI boundary.

---

### `Generated/` - Auto-Generated Files

**âš ï¸ NEVER EDIT THESE FILES MANUALLY**

They are regenerated on every build if `shared.udl` changes.

- `shared.swift` - Swift functions that call Rust
- `sharedFFI.h` - C header (FFI uses C ABI)
- `sharedFFI.modulemap` - Makes it a Swift module

---

## Common Questions

### Q: What serialization format is used?

**A:** **Bincode** (binary serialization). This is the Crux framework default.

**Why Bincode?**
- âœ… Faster (3-4x faster than JSON)
- âœ… Smaller (50% smaller payloads)
- âœ… Type-safe (exact Rustâ†”ï¸Swift type matching)
- âœ… Mobile-optimized (better battery life)
- âœ… Crux best practice

**For details**: See `docs/SERIALIZATION-BEST-PRACTICES.md`

---

### Q: Isn't binary serialization hard to debug?

**A:** Manageable with logging. Benefits outweigh costs:
- âœ… Much faster performance
- âœ… Type safety catches errors early
- âœ… Generated types handle all complexity
- âœ… Can add debug logging in Rust for inspection
- âœ… Tests can use JSON for readability

For a mobile app, performance matters more than inspectability. JSON is still used for import/export features where human-readability is valuable.

---

### Q: Can I call Swift from Rust?

**A:** Not directly. The pattern is:

1. Rust returns "effects" (commands to execute)
2. Swift receives effects
3. Swift executes them (e.g., show notification, save file)
4. Swift sends result back to Rust

This is the **Crux pattern**. Keeps Rust pure and testable.

---

### Q: What if I change `shared.udl`?

**A:** Just rebuild! Xcode will:
1. Regenerate bindings
2. Show compile errors if Swift code is incompatible
3. You fix Swift code
4. Done!

The compiler catches FFI mistakes.

---

### Q: How do I debug across the FFI boundary?

**Tools:**
- **Rust side:** `cargo test`, `println!`, `dbg!`
- **Swift side:** Xcode debugger, breakpoints in `CoreUniffi.swift`
- **FFI boundary:** Log JSON before/after crossing

**Pro tip:** Put `print!` statements in Rust. They show in Xcode console.

---

## Performance Characteristics

### FFI Call Overhead

**Typical call:**
```
Swift: 10-50 ns (encode to JSON)
   â†“
FFI: ~100-500 ns (cross boundary)
   â†“
Rust: 10-50 ns (decode JSON)
   â†“
[Business logic executes]
   â†“
Rust: 10-50 ns (encode to JSON)
   â†“
FFI: ~100-500 ns (cross boundary)
   â†“
Swift: 10-50 ns (decode JSON)
```

**Total FFI overhead: ~300-1300 ns per call**

For comparison, **16ms = 60 FPS**. One call is **0.0013ms**. You can make thousands per frame.

**TL;DR:** Don't worry about FFI performance for this app.

---

## Testing Strategy

### Rust Tests (Majority)

```bash
cd app/shared
cargo test
```

**Test coverage:**
- âœ… Business logic
- âœ… State management
- âœ… Database operations
- âœ… Edge cases

**Advantage:** Fast, no iOS simulator needed.

---

### Swift Tests (UI & Integration)

```bash
# In Xcode: âŒ˜U
```

**Test coverage:**
- âœ… UI navigation
- âœ… View rendering
- âœ… FFI integration
- âœ… User flows

---

## Security Considerations

### Memory Safety

**Rust side:** Memory-safe by default (ownership system)

**Swift side:** Memory-safe by default (ARC)

**FFI boundary:** **UniFFI handles this!** No manual pointer management.

**Result:** âœ… No memory leaks, no use-after-free, no buffer overflows

---

### Data Validation

**Important:** Validate data at the FFI boundary!

```rust
pub fn process_event(msg: &[u8]) -> Result<Vec<u8>, CoreError> {
    // Deserialization validates JSON structure
    let event: Event = serde_json::from_slice(msg)
        .map_err(|_| CoreError::InvalidInput)?;
    
    // Additional validation
    match event {
        Event::CreateWorkout { name } if name.is_empty() => {
            return Err(CoreError::InvalidInput);
        }
        _ => {}
    }
    
    // Process validated event
    // ...
}
```

**Never trust input, even from your own UI!**

---

## Troubleshooting

### "No such module 'SharedCore'"

**Cause:** UniFFI bindings not generated yet.

**Fix:** Run `./scripts/setup-mac.sh` or build in Xcode (âŒ˜B)

---

### "Undefined symbols for architecture"

**Cause:** Rust library not built for correct target.

**Fix:**
```bash
cd app/shared
./build-ios.sh
```

Make sure you're building for `aarch64-apple-ios-sim` (simulator) or `aarch64-apple-ios` (device).

---

### Build is Slow

**First build:** Slow (compiles all Rust dependencies)

**Subsequent builds:** Fast (incremental compilation)

**Speed up:**
```bash
# Use sccache (caching compiler)
cargo install sccache
export RUSTC_WRAPPER=sccache
```

---

## Further Reading

- **Setup:** [QUICKSTART.md](./QUICKSTART.md)
- **Main README:** [../README.md](../README.md)
- **UniFFI Official Docs:** https://mozilla.github.io/uniffi-rs/
- **Crux Framework:** https://github.com/redbadger/crux

---

## Contributing to the Architecture

When modifying the FFI boundary:

1. **Update `shared.udl`** first (the contract)
2. **Implement in Rust** (`lib.rs`)
3. **Build** (bindings regenerate automatically)
4. **Update Swift** (`CoreUniffi.swift` or views)
5. **Test** both Rust and Swift sides

**Remember:** The `.udl` file is the source of truth!

---

## Appendix A: UniFFI Migration Details

### What Changed During Migration

- âœ… Added UniFFI 0.30 dependencies
- âœ… Created `shared.udl` interface definition (single source of truth)
- âœ… Removed 325 lines of manual FFI code from `lib.rs`
- âœ… Added clean UniFFI integration (~65 lines)
- âœ… Created `CoreUniffi.swift` - simplified Swift wrapper
- âœ… Removed obsolete files: `shared.h`, `shared-Bridging-Header.h`
- âœ… Updated build scripts for automatic binding generation

### Code Impact Metrics

| Metric | Before | After | Improvement |
|--------|--------|-------|-------------|
| **FFI Code Lines** | 328 | 65 | -80% |
| **Manual Memory Mgmt** | Yes | No | âœ… Automatic |
| **Type Safety** | None | Full | âœ… Compiler-verified |
| **Maintainability** | 3 files to sync | 1 .udl file | âœ… Single source |
| **Error Handling** | Null pointers | Result types | âœ… Safe |

### Before vs After Architecture

**Before (Manual FFI):**
```
Swift â†’ Manual @_silgen_name â†’ C Header â†’ Manual #[no_mangle] â†’ Rust
       Manual OpaquePointer        shared.h        Box::into_raw
       Manual CString                              Manual memory mgmt
```

**After (UniFFI):**
```
Swift â†’ import SharedCore â†’ Auto-generated â†’ uniffi::include_scaffolding!() â†’ Rust
       Generated API          Swift/C/ModMap      Auto memory mgmt
       Type-safe             sharedFFI.*          Safe Result types
```

---

## Appendix B: Setup & Build Details

### Initial Setup (One-Time)

The `./scripts/setup-mac.sh` script at project root does everything:

```bash
cd /path/to/thiccc
./scripts/setup-mac.sh
```

**What it installs:**
1. Mint (Swift tool manager)
2. XcodeGen from Mintfile (version-pinned)
3. Rust toolchain with iOS targets
4. Builds Rust libraries for iOS
5. Generates UniFFI Swift bindings
6. Generates Xcode project

**Then run:**
```bash
cd app/ios
open thiccc/Thiccc.xcodeproj
# Hit âŒ˜R - everything works!
```

### Manual Setup (Advanced Users)

<details>
<summary>Click to expand manual setup instructions</summary>

#### 1. Install Prerequisites

```bash
# Install Homebrew (if not already installed)
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Install Mint
brew install mint

# Install XcodeGen from Mintfile (version-pinned)
cd /path/to/thiccc
mint bootstrap
```

#### 2. Install Rust

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup target add aarch64-apple-ios aarch64-apple-ios-sim
```

#### 3. Build Rust Libraries

```bash
cd app/shared
./build-ios.sh
```

This generates:
- Static libraries for iOS device and simulator
- UniFFI Swift bindings in `app/ios/thiccc/Thiccc/Generated/`

#### 4. Generate Xcode Project

```bash
cd ../ios
mint run xcodegen xcodegen generate
```

This creates `Thiccc.xcodeproj` with:
- âœ… Automatic Rust rebuilds configured
- âœ… Pre-build scripts set up
- âœ… Library search paths configured

#### 5. Open & Build

```bash
open thiccc/Thiccc.xcodeproj
# Hit âŒ˜B to build or âŒ˜R to run
```

</details>

### Build System Details

**XcodeGen** (`project.yml`) generates the `.xcodeproj` with:
- Pre-build script that rebuilds Rust if changed
- Correct library search paths
- Framework linking configuration

**UniFFI** (`build-ios.sh` + `uniffi-bindgen`) generates:
- `shared.swift` - Swift API to call Rust
- `sharedFFI.h` - C header
- `sharedFFI.modulemap` - Makes it a Swift module

### Troubleshooting Build Issues

| Issue | Solution |
|-------|----------|
| "XcodeGen not found" or "Mint not found" | Run `./scripts/setup-mac.sh` |
| "No such module 'SharedCore'" | Hit âŒ˜B to build (generates module) |
| Pre-build script fails | Check Rust installed: `rustup show` |
| Wrong XcodeGen version | `mint bootstrap` (reinstalls from Mintfile) |
| Files appear red in Xcode | Regenerate: `mint run xcodegen xcodegen generate` |

---

**Questions?**
- Setup: [QUICKSTART.md](./QUICKSTART.md)
- Project overview: [../README.md](../README.md)

