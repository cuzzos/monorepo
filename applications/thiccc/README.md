# Thiccc - Workout Tracking App

A modern iOS workout tracking app built with **Crux architecture** (Rust core + SwiftUI shell) and **UniFFI** for seamless Rust-Swift integration.

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│                     SwiftUI Shell                       │
│  • Views (WorkoutView, HistoryView, etc.)              │
│  • CoreUniffi.swift (Bridge to Rust)                   │
│  • Presentation logic only                              │
└────────────────────┬────────────────────────────────────┘
                     │
              UniFFI-Generated
              Bindings (automatic)
                     │
┌────────────────────▼────────────────────────────────────┐
│                    Rust Core                            │
│  • All business logic (Crux App)                       │
│  • State management (Model)                             │
│  • Event handling (Event → Model)                       │
│  • SQLite database (rusqlite)                           │
└─────────────────────────────────────────────────────────┘
```

## Features

- ✅ Create and track workouts
- ✅ Add exercises with sets (reps, weight, rest time)
- ✅ Timer for workout duration and rest periods
- ✅ Workout history with detailed views
- ✅ Plate calculator for barbell loading
- ✅ SQLite persistence
- ✅ Import/export workouts (JSON)
- ✅ **UniFFI integration** - automatic FFI bindings

## Technology Stack

### Rust Core (`app/shared/`)
- **Rust 2024 Edition** (latest stable)
- **Crux 0.16.1** - Cross-platform app framework
- **UniFFI 0.30** - Automatic FFI binding generation
- **rusqlite 0.37** - SQLite database
- **serde** - JSON serialization
- **uuid**, **chrono** - IDs and timestamps

### iOS Shell (`app/ios/`)
- **iOS 18.0+** (minimum deployment target)
- **Swift 6.0+**
- **SwiftUI** - Declarative UI
- **UniFFI-generated bindings** - Type-safe Rust-Swift bridge

## Project Structure

```
thiccc/
├── Mintfile                      # Swift tool versions (XcodeGen) ⭐
├── setup-mac.sh                 # One-command macOS setup ⭐
│
├── app/
│   ├── shared/                    # Rust Core (Crux + UniFFI)
│   │   ├── src/
│   │   │   ├── lib.rs            # Crux App + UniFFI integration
│   │   │   ├── models.rs         # Data models (Workout, Exercise, etc.)
│   │   │   ├── database.rs       # SQLite operations
│   │   │   ├── shared.udl        # UniFFI interface definition ⭐
│   │   │   └── bin/
│   │   │       └── uniffi-bindgen.rs  # CLI tool for bindings
│   │   ├── build.rs              # Auto-generates UniFFI scaffolding
│   │   ├── uniffi.toml           # UniFFI configuration
│   │   ├── Cargo.toml            # Rust dependencies
│   │   └── build-ios.sh          # Build script (initial setup)
│   │
│   ├── ios/
│   │   ├── project.yml           # XcodeGen specification ⭐
│   │   └── thiccc/Thiccc/        # iOS App (SwiftUI Shell)
│   │       ├── ThicccApp.swift   # App entry point
│   │       ├── CoreUniffi.swift  # Rust bridge (uses UniFFI) ⭐
│   │       ├── Views/            # SwiftUI views
│   │       ├── Models/           # Swift models (match Rust types)
│   │       └── Generated/        # Auto-generated UniFFI bindings
│   │           ├── shared.swift      # (auto-generated by Xcode)
│   │           ├── sharedFFI.h       # (auto-generated by Xcode)
│   │           └── sharedFFI.modulemap
│
├── UNIFFI-SUMMARY.md            # Quick start guide
├── UNIFFI-MIGRATION.md          # Detailed migration guide
├── MIGRATION-STATUS.md          # Project completion status
└── README.md                    # This file
```

## Quick Start

### Development Environment

- **Devcontainer**: For Rust development (Linux)
- **macOS**: For iOS development (Xcode + XcodeGen)

### Option 1: Automated Setup (Recommended)

**On your Mac, run one command:**

```bash
cd /path/to/thiccc
./setup-mac.sh
```

This script:
- ✅ Installs Homebrew (if needed)
- ✅ Installs XcodeGen
- ✅ Installs/updates Rust
- ✅ Adds iOS targets
- ✅ Builds Rust libraries
- ✅ Generates Xcode project

Then just open Xcode and hit ⌘R!

### Option 2: Manual Setup

**Prerequisites:**
```bash
# On macOS
brew install mint
mint bootstrap  # Installs XcodeGen from Mintfile
rustup target add aarch64-apple-ios aarch64-apple-ios-sim
```

**Build & Generate:**
```bash
# 1. Build Rust libraries
cd app/shared
./build-ios.sh

# 2. Generate Xcode project
cd ../ios
mint run xcodegen xcodegen generate

# 3. Open Xcode
open thiccc/Thiccc.xcodeproj
```

**That's it!** Hit ⌘R in Xcode and it will:
- ✅ Automatically rebuild Rust if code changed
- ✅ Automatically regenerate Swift bindings
- ✅ Build and run the app

### 5. Update Swift Code (One-Time)

In `CoreUniffi.swift`, make these changes once:

**Uncomment:**
```swift
import SharedCore
```

**Replace:**
```swift
let viewBytes = try self.processEventFallback(eventBytes)
```

**With:**
```swift
let viewBytes = try processEvent(msg: eventBytes)
```

Then select **iPhone 15 Pro** simulator and ⌘R to build!

## Development

### Daily Workflow

**Rust development:**
```bash
# Option A: Edit in devcontainer (Linux)
code .  # Opens in VSCode devcontainer

# Option B: Edit on Mac
vim app/shared/src/lib.rs
```

**iOS build:**
```bash
# On your Mac
open app/ios/thiccc/Thiccc.xcodeproj
# Hit ⌘R - Xcode automatically rebuilds Rust and regenerates bindings
```

**Benefits of devcontainer:**
- ✅ Consistent Rust development environment
- ✅ Pre-configured with rust-analyzer
- ✅ Can run `cargo check`, `cargo test`, etc.
- ✅ Works on any machine with Docker

**Note:** XcodeGen and iOS builds require macOS. Rust development can happen anywhere.

### Rust Development Commands

```bash
cd app/shared

# Check for errors
cargo check

# Run tests
cargo test

# Manual build (optional - Xcode does this automatically)
cargo build --release --target aarch64-apple-ios-sim
```

### Modifying the FFI Interface

1. Edit `app/shared/src/shared.udl` (the interface definition)
2. Hit ⌘R in Xcode - bindings regenerate automatically!

**Example**: Adding a new function:

```udl
namespace shared {
    bytes process_event([ByRef] bytes msg);
    bytes view();
    bytes handle_response(u32 id, [ByRef] bytes res);
    
    // Add new function here:
    bytes get_workout_stats(string workout_id);  // ← New!
};
```

Then implement in Rust:

```rust
pub fn get_workout_stats(workout_id: &str) -> Result<Vec<u8>, CoreError> {
    // Implementation
}
```

Hit ⌘R in Xcode - done! UniFFI generates all Swift/C bridge code automatically.

### iOS Development

All SwiftUI views use the `RustCoreUniffi` observable object:

```swift
@StateObject private var core = RustCoreUniffi()

// Dispatch events
core.dispatch(.createWorkout(name: "Morning Workout"))
core.dispatch(.addExercise(globalExercise: exercise))

// Observe view model updates
Text(core.viewModel.formattedTime)
```

### Regenerating Xcode Project

If you modify `project.yml`:

```bash
cd app/ios
mint run xcodegen xcodegen generate
# Xcode will prompt to reload - click "Reload"
```

### Tool Versions

XcodeGen version is pinned in `Mintfile` for reproducible builds. To update:

```bash
# Update Mintfile version
vim Mintfile

# Install new version
mint bootstrap
```

## Key Concepts

### Crux Architecture

**Crux** separates apps into:
- **Core** (Rust): Pure business logic, runs anywhere (iOS, Android, web)
- **Shell** (Swift/Kotlin/etc): Thin UI layer

**Flow:**
```
User Action → Event → Rust Core → Updated Model → ViewModel → SwiftUI Update
```

### UniFFI Integration

**UniFFI** automatically generates FFI bindings from a `.udl` file:

**Before (Manual FFI)**: ~328 lines of manual pointer handling, string conversions, memory management

**After (UniFFI)**: ~65 lines, all safety handled automatically

**Benefits:**
- ✅ 80% less code
- ✅ Type-safe across FFI boundary
- ✅ Automatic memory management
- ✅ Single source of truth (`.udl` file)
- ✅ Cross-platform (same `.udl` works for Android)

### Data Flow Example

```swift
// 1. User taps "Start Workout"
core.dispatch(.createWorkout(name: "Chest Day"))

// 2. Swift → JSON → bytes
let eventJson = try JSONEncoder().encode(event)
let eventBytes = [UInt8](eventJson)

// 3. UniFFI-generated binding calls Rust
let viewBytes = try processEvent(msg: eventBytes)

// 4. Rust processes event, updates model
// (All business logic happens here)

// 5. Rust returns updated ViewModel as bytes
// 6. Swift decodes and updates UI
let viewModel = try JSONDecoder().decode(ViewModel.self, from: Data(viewBytes))
core.viewModel = viewModel  // Triggers SwiftUI update
```

## Documentation

- **[UNIFFI-SUMMARY.md](./UNIFFI-SUMMARY.md)** - Quick start guide for UniFFI
- **[UNIFFI-MIGRATION.md](./UNIFFI-MIGRATION.md)** - Detailed UniFFI migration guide
- **[MIGRATION-STATUS.md](./MIGRATION-STATUS.md)** - Project completion status
- **[BUILD-INSTRUCTIONS.md](./BUILD-INSTRUCTIONS.md)** - Manual build steps
- **[SETUP.md](./SETUP.md)** - iOS app setup guide

## Troubleshooting

### "No such module 'SharedCore'"
→ Generated folder not added to Xcode. See [Quick Start](#quick-start) step 4.

### Build fails with UniFFI errors
→ Clean and rebuild:
```bash
cd app/shared
cargo clean
./build-ios.sh
```

### Linker errors in Xcode
→ Make sure you're using the correct architecture:
- Simulator: Use `aarch64-apple-ios-sim` (Apple Silicon)
- Device: Use `aarch64-apple-ios`

### "Function not found" errors
→ Rebuild Rust libraries after changing code:
```bash
cd app/shared
./build-ios.sh
```

## Contributing

### Code Style

**Rust:**
- Use `rustfmt` (runs automatically)
- Follow [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- Document public APIs with `///` comments

**Swift:**
- Follow [Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/)
- Use SwiftUI declarative patterns
- Keep shell layer thin (no business logic)

### Testing

**Rust tests:**
```bash
cd app/shared
cargo test
```

**iOS tests:**
Run tests in Xcode (⌘U)

## License

[Add your license here]

## Credits

Built with:
- [Crux](https://github.com/redbadger/crux) - Cross-platform app framework
- [UniFFI](https://mozilla.github.io/uniffi-rs/) - FFI binding generator
- [rusqlite](https://github.com/rusqlite/rusqlite) - SQLite for Rust

---

**Status**: ✅ UniFFI migration complete - Ready for testing  
**Last Updated**: November 14, 2025

