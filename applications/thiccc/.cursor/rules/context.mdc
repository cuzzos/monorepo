---
description: Principal engineer standards for thiccc application - technology stack and architecture requirements
alwaysApply: true
---

# Thiccc Application - Principal Engineer Standards

Standards specific to the thiccc application. For universal AI agent behavior principles, see the root `agent-principles.mdc`.

## Technology Requirements

**CRITICAL**: All implementations must use the latest stable versions:

- **Rust**: Rust 2024 edition (latest stable)
- **iOS SDK**: iOS 18.0+ (latest SDK)
- **Minimum iOS Deployment**: iOS 18.0 (no backward compatibility required)
- **Swift**: Swift 6.0+
- **Xcode**: Latest version supporting iOS 18 SDK

**NEVER** use deprecated APIs or patterns. Always verify current best practices.

## Technology Stack Standards

### Rust (Core Business Logic)

- **Edition**: Rust 2024
- **Documentation Sources**:
  - Official Rust Book (doc.rust-lang.org/book/)
  - Rust API Guidelines (rust-lang.github.io/api-guidelines/)
  - Cargo Book (doc.rust-lang.org/cargo/)
- **Best Practices**:
  - Follow Rust API Guidelines for naming, error handling, and documentation
  - Use `Result<T, E>` for error handling, never panic in library code
  - Write comprehensive tests with `#[cfg(test)]` modules
  - Use `clippy` lints and `rustfmt` for code quality
  - No unsafe code without justification

### Crux Framework

- **Documentation**: github.com/redbadger/crux
- **Architecture Pattern**: Strict adherence to Crux architecture
  - Pure business logic in Rust core
  - Platform-agnostic capabilities
  - Thin shell layer (iOS SwiftUI)
- **Best Practices**:
  - Keep all business logic in the Rust core
  - Use capabilities for platform-specific operations
  - Ensure events are serializable (serde)
  - Maintain pure functions in update and view

### SwiftUI (iOS Shell)

- **iOS SDK**: iOS 18.0+
- **Minimum Deployment Target**: iOS 18.0
- **Best Practices**:
  - Follow SwiftUI declarative patterns
  - Use `@Bindable`, `@Observable` appropriately
  - Do not use `@ObservableObject`, `@Binding`, nor `@Published`
  - Use modern Swift concurrency (async/await)
  - Leverage iOS 18+ specific APIs and features

## Dependency Management

### Rust Dependencies

- **ALWAYS** check latest version on crates.io
- **VERIFY** compatibility with Rust 2024 edition
- **REVIEW** crate documentation and examples
- **CHECK** for security advisories (rustsec.org)
- **PREFER** well-maintained crates with active development

### Swift Dependencies

- **USE** Swift Package Manager for dependencies
- **VERIFY** compatibility with iOS 18.0+
- **CHECK** for Swift 6.0+ compatibility
- **ENSURE** dependencies support iOS 18.0+ SDK

## Architecture Compliance

### Crux Architecture Rules

- **Core (Rust)**: Contains ALL business logic, state management, and data models
- **Shell (Swift)**: Thin UI layer that renders ViewModels from core
- **Capabilities**: Platform-specific operations (storage, HTTP, etc.)
- **Events**: All user actions flow through events to core
- **ViewModels**: Core transforms Model into ViewModel for rendering

### Violations to Avoid

- Business logic in SwiftUI views
- Direct database access from Swift
- State management outside of Rust core
- Platform-specific logic in shared core

## Testing Standards

### Rust Tests

- Unit tests for all business logic
- Integration tests for event handling
- Property-based tests for complex algorithms
- Test coverage for error paths
- **100% line coverage required** (see `rust-coverage.mdc`)

### Swift Tests

- UI tests for critical user flows
- Unit tests for Swift bridge layer
- Snapshot tests for UI components (if applicable)

## Performance Standards

### Rust Performance

- Use appropriate data structures (Vec vs HashMap vs BTreeMap)
- Avoid unnecessary allocations
- Profile before optimizing
- Use `cargo bench` for benchmarking

### Swift Performance

- Avoid unnecessary view updates
- Use `@State` and `@Bindable` efficiently
- Implement lazy loading for large lists
- Profile with Instruments

## Error Handling

### Rust Error Handling

- Use `Result<T, E>` for recoverable errors
- Use `thiserror` or `anyhow` for error types
- Provide meaningful error messages
- Log errors appropriately

### Swift Error Handling

- Use `do-catch` blocks for throwing functions
- Present user-friendly error messages
- Log errors for debugging
- Handle network errors gracefully

## Mandatory Workflow

### Quick Reference: Essential Commands

**READ THIS FIRST:** For detailed command usage, see `agent-workflow.mdc`.

**Most Common Commands:**

```bash
make test-rust          # Run Rust tests (2-3 seconds)
make coverage-check     # Verify 100% coverage (BEFORE completing tasks)
make run-sim            # Build and test in iOS simulator
./scripts/verify-rust-core.sh  # Complete validation (BEFORE handoff)
```

**When to use each:**

- Made Rust changes? → `make test-rust` → `make coverage-check`
- Made Swift changes? → `make run-sim`
- Completing a task? → `./scripts/verify-rust-core.sh`
- Not sure? → `make help`

### Development Workflow Steps

1. **Understand** the requirement completely
2. **Search** the codebase for existing patterns
3. **Implement** following established patterns
4. **Test** using appropriate Makefile commands
5. **Verify 100% coverage** with `make coverage-check`
6. **Run full validation** with `./scripts/verify-rust-core.sh`

## Final Reminder

**Act as a Principal Engineer**: Your code will be reviewed by senior engineers, used in production, and maintained for years. Every decision should be defensible, every pattern should be intentional.
