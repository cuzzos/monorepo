---
title: Rust Code Coverage Requirements
description: Enforce 100% line coverage for Rust core business logic
---

# Rust Code Coverage - 100% Line Coverage Required

## Overview

All Rust code in the `app/shared/` crate MUST maintain **100% line coverage**. This ensures every line of business logic is tested and reduces bugs in production.

## Coverage Requirements

### Required: 100% Line Coverage

**What it means:** Every line of code must be executed by at least one test.

**Enforced on:**
- ‚úÖ `app/shared/src/app.rs` - Core business logic (Events, Model, update(), view())
- ‚úÖ `app/shared/src/models.rs` - Domain models (Workout, Exercise, etc.)
- ‚úÖ `app/shared/src/operations.rs` - Business operations
- ‚úÖ `app/shared/src/id.rs` - ID generation utilities
- ‚úÖ All other source files in `app/shared/src/`

**Excluded from coverage:**
- ‚ùå `app/shared/src/lib.rs` - FFI bridge (auto-generated by UniFFI)
- ‚ùå Generated UniFFI bindings
- ‚ùå Build scripts (`build.rs`)

### Optional: Branch Coverage

**What it means:** Every decision path (if/else, match arms) is tested.

**Status:** Not required initially, but recommended for critical logic.

## Tools

### Primary: cargo-llvm-cov

```bash
# Install
cargo install cargo-llvm-cov

# Run coverage with 100% threshold
make coverage

# View HTML report
make coverage-report

# Check if coverage meets 100% (fails if below)
make coverage-check
```

### Alternative: tarpaulin

```bash
# Install (if cargo-llvm-cov doesn't work)
cargo install cargo-tarpaulin

# Run
cargo tarpaulin --out Html --output-dir coverage/
```

## Makefile Commands

All coverage commands are available via `make`:

```bash
# Run tests with coverage and generate report
make coverage

# Open HTML coverage report in browser
make coverage-report

# Check if coverage meets 100% threshold (CI-ready)
make coverage-check
```

## Workflow for AI Agents

When modifying Rust code in `app/shared/`:

1. **Write code** as normal
2. **Write tests** for all new code paths
3. **Run coverage:** `make coverage-check`
4. **If coverage < 100%:**
   - Run `make coverage-report` to see what's missing
   - Add tests for uncovered lines
   - Repeat until 100%
5. **Commit** only when coverage is 100%

## Coverage Report Example

```bash
$ make coverage-check
üß™ Running tests with coverage...
üîç Checking coverage threshold (100%)...

Filename                      Lines    Regions    Functions
--------------------------------------------------------
app/src/app.rs               100.00%   98.50%     100.00%
app/src/models.rs            100.00%   100.00%    100.00%
app/src/operations.rs        100.00%   100.00%    100.00%
app/src/id.rs                100.00%   100.00%    100.00%
--------------------------------------------------------
TOTAL                        100.00%   99.12%     100.00%

‚úÖ Coverage meets 100% threshold!
```

## Handling Untestable Code

If you have code that is genuinely untestable (rare), you can exclude it:

```rust
// Exclude entire function
#[cfg(not(tarpaulin_include))]
fn unreachable_panic_handler() {
    panic!("This should never be called");
}

// Exclude specific lines (use sparingly!)
fn conditional_logic(x: i32) -> i32 {
    if x > 0 {
        x * 2
    } else {
        #[cfg(not(tarpaulin_include))]
        unreachable!("x should always be positive in production")
        
        x // This line needs a test
    }
}
```

**‚ö†Ô∏è WARNING:** Use exclusions VERY sparingly. Document why code is excluded.

## Common Scenarios

### Adding a New Event

```rust
// In app.rs
pub enum Event {
    StartWorkout,
    // NEW: Your new event
    PauseWorkout,
}

// In update()
match event {
    Event::StartWorkout => { /* ... */ }
    // NEW: Must have test!
    Event::PauseWorkout => {
        model.workout_paused = true;
    }
}
```

**Required test:**
```rust
#[test]
fn test_pause_workout() {
    let mut model = Model::default();
    model.current_workout = Some(Workout::new());
    
    update(Event::PauseWorkout, &mut model);
    
    assert!(model.workout_paused);
}
```

### Adding a New Model Method

```rust
// In models.rs
impl Workout {
    // NEW: Must have test!
    pub fn total_volume(&self) -> f64 {
        self.exercises.iter()
            .flat_map(|e| &e.sets)
            .map(|s| s.weight * s.reps as f64)
            .sum()
    }
}
```

**Required test:**
```rust
#[test]
fn test_workout_total_volume() {
    let mut workout = Workout::new();
    workout.add_exercise(Exercise::new("Bench Press"));
    workout.exercises[0].add_set(ExerciseSet {
        weight: 225.0,
        reps: 5,
        ..Default::default()
    });
    
    assert_eq!(workout.total_volume(), 1125.0);
}
```

### Handling Error Paths

```rust
pub fn validate_set(set: &ExerciseSet) -> Result<(), ValidationError> {
    if set.weight < 0.0 {
        return Err(ValidationError::NegativeWeight);
    }
    if set.reps == 0 {
        return Err(ValidationError::ZeroReps);
    }
    Ok(())
}
```

**Required tests (both paths):**
```rust
#[test]
fn test_validate_set_success() {
    let set = ExerciseSet { weight: 100.0, reps: 5, ..Default::default() };
    assert!(validate_set(&set).is_ok());
}

#[test]
fn test_validate_set_negative_weight() {
    let set = ExerciseSet { weight: -10.0, reps: 5, ..Default::default() };
    assert!(matches!(validate_set(&set), Err(ValidationError::NegativeWeight)));
}

#[test]
fn test_validate_set_zero_reps() {
    let set = ExerciseSet { weight: 100.0, reps: 0, ..Default::default() };
    assert!(matches!(validate_set(&set), Err(ValidationError::ZeroReps)));
}
```

## Integration with Verification Script

The `scripts/verify-rust-core.sh` script includes coverage checks:

```bash
./scripts/verify-rust-core.sh
```

This runs:
1. ‚úÖ Rust compilation
2. ‚úÖ Clippy lints
3. ‚úÖ All tests
4. ‚úÖ **Coverage check (100% required)**
5. ‚úÖ Swift type generation

**DO NOT** mark any task complete until this script passes.

## CI/CD Integration (Future)

When CI/CD is set up, coverage will be enforced:

```yaml
# .github/workflows/rust-tests.yml
- name: Run tests with coverage
  run: cd applications/thiccc && make coverage-check

- name: Upload coverage report
  if: failure()
  uses: actions/upload-artifact@v3
  with:
    name: coverage-report
    path: applications/thiccc/app/shared/coverage/
```

## Why 100% Coverage?

**Benefits:**
- ‚úÖ **Catches bugs early** - Every line is tested before merge
- ‚úÖ **Prevents regressions** - Changes that break tests are caught
- ‚úÖ **Documents behavior** - Tests serve as executable specifications
- ‚úÖ **Enables refactoring** - Change code confidently knowing tests will catch breaks
- ‚úÖ **Reduces debugging time** - Fewer production bugs

**Common concerns:**
- ‚ùì "100% is too strict" - For Crux architecture where ALL business logic is in Rust, 100% is achievable and valuable
- ‚ùì "Takes too long" - Tests run in <2 seconds, coverage adds ~1 second
- ‚ùì "Tests for tests' sake" - Good tests prevent real bugs, not just achieve metrics

## Troubleshooting

### Coverage tool not found

```bash
error: no such subcommand: `llvm-cov`

# Solution:
cargo install cargo-llvm-cov
```

### Coverage below 100%

```bash
# View HTML report to see what's missing
make coverage-report

# Look for red (uncovered) lines in the HTML report
# Add tests for those lines
```

### False negatives (code is tested but shows uncovered)

This is rare with `cargo-llvm-cov`. If it happens:
- Ensure tests are in the same crate (`#[cfg(test)]` modules in same file)
- Check that tests are actually running (`cargo test`)
- Try `cargo clean` and re-run coverage

### Exclusion not working

```rust
// Make sure you use the right attribute
#[cfg(not(tarpaulin_include))]  // For tarpaulin
// or
#[cfg(not(coverage))]            // For llvm-cov
```

For best compatibility, use both:
```rust
#[cfg(all(not(tarpaulin_include), not(coverage)))]
fn unreachable_code() { }
```

## Resources

- [cargo-llvm-cov documentation](https://github.com/taiki-e/cargo-llvm-cov)
- [Rust testing guide](https://doc.rust-lang.org/book/ch11-00-testing.html)
- [Code coverage best practices](https://martinfowler.com/bliki/TestCoverage.html)

---

**Last Updated**: December 13, 2025
**Status**: MANDATORY for all Rust code modifications
**Enforced By**: AI agents, verification script, future CI/CD
