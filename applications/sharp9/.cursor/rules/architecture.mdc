---
description: Elm-inspired architecture patterns for Sharp9 iOS app - pure functional core with impure shell
globs:
  - "**/*.swift"
alwaysApply: true
---

# Sharp9 Architecture - Elm-Inspired Functional Design

This document defines the architectural patterns for Sharp9, following an Elm-inspired approach with a pure functional core and impure shell for side effects.

## Core Philosophy

**Pure functional core, impure shell.** Business logic lives in pure functions operating on immutable data structures. Side effects (audio engine, file I/O, timers) are isolated in protocol-based services.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                          UI Layer                           │
│  (SwiftUI views - read state, send messages)                │
│  - Minimal logic (only coordinate→time geometry)            │
│  - IMPORTS: SwiftUI only                                    │
│  - NEVER: AVFoundation, Domain internals, direct mutation   │
└─────────────────────────────────────────────────────────────┘
                              ▲
                              │ observes state
                              │ sends Msg
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       AppGlue Layer                         │
│  Core (Store) - owns Model + runs Commands                  │
│  - @Observable @MainActor final class                       │
│  - Calls update(), executes Commands via EffectRunner       │
│  - IMPORTS: Domain, Engine, SwiftUI                         │
└─────────────────────────────────────────────────────────────┘
          │                           │
          │ update()                  │ run(Command)
          ▼                           ▼
┌──────────────────────┐    ┌──────────────────────┐
│   Domain Layer       │    │   Engine Layer       │
│ (Pure functions)     │    │ (Impure services)    │
│                      │    │                      │
│ • Model (structs)    │    │ • AudioEngine        │
│ • Msg (enum)         │    │   protocol           │
│ • Command (enum)     │    │ • DefaultAudio-      │
│ • update() function  │    │   Engine (class)     │
│ • Selectors          │    │ • WaveformPeak-      │
│ • Formatting         │    │   Computer           │
│                      │    │                      │
│ IMPORTS: Foundation  │    │ IMPORTS:             │
│ NEVER: SwiftUI,      │    │   AVFoundation,      │
│        AVFoundation, │    │   Accelerate         │
│        UIKit         │    │ NEVER: SwiftUI       │
└──────────────────────┘    └──────────────────────┘
```

---

## Layer 1: Domain (Pure Functional Core)

### What Lives Here

**Pure data structures and pure functions only.**

- ✅ `struct` models (immutable state)
- ✅ `enum` messages (user intents + system events)
- ✅ `enum` commands (side effect descriptions)
- ✅ Pure `update()` function: `(Model, Msg) -> (Model, [Command])`
- ✅ Pure selectors: `(Model) -> DerivedValue`
- ✅ Pure formatters: `(Value) -> String`

**NEVER:**
- ❌ Classes (except for organizing static functions)
- ❌ Side effects (network, file I/O, timers, audio)
- ❌ SwiftUI imports
- ❌ AVFoundation imports
- ❌ Mutable state
- ❌ Async functions (use Commands instead)

### File Structure

```
Domain/
├── Models/
│   ├── PlayerModel.swift        # Main app state (struct)
│   ├── Mode.swift               # enum: marker, setA, loop, setB
│   ├── Marker.swift             # struct: id, timeSec
│   ├── LoopPoints.swift         # struct: aSec, bSec, enabled
│   ├── Transport.swift          # struct: isPlaying, currentTimeSec, speed, pitch
│   ├── TrackMeta.swift          # struct: name, durationSec
│   ├── Viewport.swift           # struct: startSec, endSec
│   └── ToastState.swift         # struct: message, expiresAt
├── Messages/
│   ├── Msg.swift                # All user/system events (enum)
│   └── Command.swift            # Side effect descriptions (enum)
└── Logic/
    ├── Update.swift             # Pure update function
    ├── Selectors.swift          # Computed state queries
    └── Formatting.swift         # Value formatters
```

### Model Pattern (Pure State)

```swift
// Domain/Models/PlayerModel.swift
struct PlayerModel: Sendable {
    var track: TrackMeta?
    var transport: Transport
    var loop: LoopPoints
    var mode: Mode
    var markers: [Marker]
    var viewport: Viewport
    var isLoading: Bool
    var toast: ToastState?
    
    // Default constructor
    init(
        track: TrackMeta? = nil,
        transport: Transport = Transport(),
        loop: LoopPoints = LoopPoints(),
        mode: Mode = .loop,
        markers: [Marker] = [],
        viewport: Viewport = Viewport(startSec: 0, endSec: 0),
        isLoading: Bool = false,
        toast: ToastState? = nil
    ) {
        self.track = track
        self.transport = transport
        self.loop = loop
        self.mode = mode
        self.markers = markers
        self.viewport = viewport
        self.isLoading = isLoading
        self.toast = toast
    }
}

// All nested models are also structs
struct Transport: Sendable {
    var isPlaying: Bool = false
    var currentTimeSec: Double = 0.0
    var speed: Double = 1.0
    var pitchSemitones: Double = 0.0
}

struct LoopPoints: Sendable {
    var aSec: Double? = nil
    var bSec: Double? = nil
    var enabled: Bool = false
}
```

### Message Pattern (Events)

```swift
// Domain/Messages/Msg.swift
enum Msg: Sendable {
    // Lifecycle
    case onAppear
    
    // Import flow
    case importPicked(url: URL)
    case importSucceeded(track: TrackMeta)
    case importFailed(message: String)
    
    // Mode selection
    case setMode(Mode)
    
    // Waveform interaction
    case tapWaveform(timeSec: Double)
    case dragScrub(timeSec: Double)
    
    // Transport controls
    case togglePlay
    case tick(currentTimeSec: Double)
    
    // Speed/pitch
    case speedDelta(Double)
    case pitchDelta(Double)
    
    // Markers
    case addMarker(timeSec: Double)
    case deleteMarker(id: UUID)
    
    // Loop controls
    case toggleLoopEnabled(Bool)
    case setA(timeSec: Double)
    case setB(timeSec: Double)
    
    // Toast
    case clearToastIfExpired(now: Date)
}
```

### Command Pattern (Side Effects)

```swift
// Domain/Messages/Command.swift
enum Command: Sendable {
    // Engine commands
    case engineLoad(url: URL)
    case enginePlay(fromTimeSec: Double)
    case enginePause
    case engineSeek(timeSec: Double)
    case engineSetRate(Double)
    case engineSetPitchSemitones(Double)
    case engineSetLoop(aSec: Double?, bSec: Double?, enabled: Bool)
    
    // Waveform computation
    case computePeaks(url: URL, targetBuckets: Int)
    
    // Timer management
    case startTimeTracking
    case stopTimeTracking
}
```

### Update Function (Pure Logic)

```swift
// Domain/Logic/Update.swift
enum Update {
    /// Pure state transition function
    /// - Parameters:
    ///   - model: Current state (will be mutated)
    ///   - msg: Event to process
    ///   - now: Current time (injected for testability)
    /// - Returns: Array of commands to execute
    static func update(
        model: inout PlayerModel,
        msg: Msg,
        now: @Sendable () -> Date = Date.init
    ) -> [Command] {
        switch msg {
        case .onAppear:
            return []
            
        case .importPicked(let url):
            model.isLoading = true
            model.track = nil
            model.transport.isPlaying = false
            model.transport.currentTimeSec = 0
            model.loop = LoopPoints()
            model.markers = []
            return [
                .enginePause,
                .engineLoad(url: url)
            ]
            
        case .importSucceeded(let track):
            model.track = track
            model.isLoading = false
            model.viewport = Viewport(startSec: 0, endSec: track.durationSec)
            model.transport.currentTimeSec = 0
            return [
                .computePeaks(url: track.url, targetBuckets: 1000)
            ]
            
        case .importFailed(let message):
            model.isLoading = false
            model.toast = ToastState(
                message: message,
                expiresAt: now().addingTimeInterval(3.0)
            )
            return []
            
        case .togglePlay:
            if model.transport.isPlaying {
                model.transport.isPlaying = false
                return [.enginePause, .stopTimeTracking]
            } else {
                model.transport.isPlaying = true
                return [
                    .enginePlay(fromTimeSec: model.transport.currentTimeSec),
                    .startTimeTracking
                ]
            }
            
        case .speedDelta(let delta):
            let newSpeed = (model.transport.speed + delta).clamped(to: 0.25...2.0)
            model.transport.speed = newSpeed
            model.toast = ToastState(
                message: "Speed \(Formatting.formatSpeed(newSpeed))",
                expiresAt: now().addingTimeInterval(1.5)
            )
            return [.engineSetRate(newSpeed)]
            
        case .setA(let timeSec):
            model.loop.aSec = timeSec
            // Auto-swap if needed
            if let a = model.loop.aSec, let b = model.loop.bSec, a > b {
                swap(&model.loop.aSec, &model.loop.bSec)
            }
            return [
                .engineSetLoop(
                    aSec: model.loop.aSec,
                    bSec: model.loop.bSec,
                    enabled: model.loop.enabled
                )
            ]
            
        case .toggleLoopEnabled(let enabled):
            guard model.loop.aSec != nil && model.loop.bSec != nil else {
                model.toast = ToastState(
                    message: "Set A and B",
                    expiresAt: now().addingTimeInterval(2.0)
                )
                return []
            }
            model.loop.enabled = enabled
            return [
                .engineSetLoop(
                    aSec: model.loop.aSec,
                    bSec: model.loop.bSec,
                    enabled: enabled
                )
            ]
            
        case .tick(let currentTimeSec):
            model.transport.currentTimeSec = currentTimeSec
            return []
            
        case .clearToastIfExpired(let now):
            if let toast = model.toast, now >= toast.expiresAt {
                model.toast = nil
            }
            return []
            
        // ... other cases
        default:
            return []
        }
    }
}

// Helper extension
extension Double {
    func clamped(to range: ClosedRange<Double>) -> Double {
        min(max(self, range.lowerBound), range.upperBound)
    }
}
```

### Selectors (Derived State)

```swift
// Domain/Logic/Selectors.swift
enum Selectors {
    /// Returns normalized loop range (always a <= b)
    static func loopRange(_ model: PlayerModel) -> (Double, Double)? {
        guard let a = model.loop.aSec, let b = model.loop.bSec else {
            return nil
        }
        return (min(a, b), max(a, b))
    }
    
    /// Can the user enable looping?
    static func canLoop(_ model: PlayerModel) -> Bool {
        model.loop.aSec != nil && model.loop.bSec != nil
    }
    
    /// Is there a track loaded?
    static func hasTrack(_ model: PlayerModel) -> Bool {
        model.track != nil
    }
    
    /// Progress ratio [0, 1]
    static func progress(_ model: PlayerModel) -> Double {
        guard let track = model.track, track.durationSec > 0 else {
            return 0
        }
        return model.transport.currentTimeSec / track.durationSec
    }
}
```

### Formatting (Pure Transformations)

```swift
// Domain/Logic/Formatting.swift
enum Formatting {
    /// Format time as "MM:SS.xx"
    static func formatTime(_ seconds: Double) -> String {
        let duration = Duration.seconds(seconds)
        return duration.formatted(.time(pattern: .minuteSecond(padMinuteToLength: 2)))
    }
    
    /// Format speed as "1.00x"
    static func formatSpeed(_ speed: Double) -> String {
        String(format: "%.2fx", speed)
    }
    
    /// Format pitch as "+3.00st" or "-3.00st"
    static func formatPitch(_ semitones: Double) -> String {
        let sign = semitones >= 0 ? "+" : ""
        return "\(sign)\(String(format: "%.2f", semitones))st"
    }
}
```

---

## Layer 2: Engine (Impure Service Shell)

### What Lives Here

**Protocol-based services that perform side effects.**

- ✅ `protocol` definitions (boundaries)
- ✅ `class` implementations (AVFoundation, file I/O, etc.)
- ✅ `async` functions for I/O
- ✅ Callbacks for streaming events (time updates)
- ✅ AVFoundation, Accelerate imports

**NEVER:**
- ❌ SwiftUI imports
- ❌ Business logic (that belongs in Domain)
- ❌ Direct state mutation (return values or call callbacks)

### File Structure

```
Engine/
├── AudioEngine.swift              # Protocol definition
├── DefaultAudioEngine.swift       # AVFoundation implementation
├── WaveformPeaks.swift            # Data structure
└── WaveformPeakComputer.swift     # Async peak computation
```

### AudioEngine Protocol

```swift
// Engine/AudioEngine.swift
import Foundation

/// Protocol boundary between pure domain logic and AVFoundation
protocol AudioEngine: AnyObject, Sendable {
    /// Callback for streaming time updates during playback
    var onTimeUpdate: (@Sendable (Double) -> Void)? { get set }
    
    /// Load audio file and return metadata
    func load(url: URL) async throws -> TrackMeta
    
    /// Start playback from current position
    func play()
    
    /// Pause playback
    func pause()
    
    /// Seek to specific time
    func seek(to timeSec: Double)
    
    /// Set playback rate (speed)
    func setRate(_ rate: Double)
    
    /// Set pitch shift in semitones
    func setPitchSemitones(_ semitones: Double)
    
    /// Configure loop points
    func setLoop(aSec: Double?, bSec: Double?, enabled: Bool)
    
    /// Get current playback time
    func currentTimeSec() -> Double
}
```

### DefaultAudioEngine Implementation

```swift
// Engine/DefaultAudioEngine.swift
import AVFoundation
import Accelerate

final class DefaultAudioEngine: AudioEngine {
    // MARK: - Properties
    
    private let engine = AVAudioEngine()
    private let player = AVAudioPlayerNode()
    private let timePitch = AVAudioUnitTimePitch()
    
    private var audioFile: AVAudioFile?
    private var trackDuration: TimeInterval = 0
    
    // Loop state
    private var loopStart: AVAudioFramePosition?
    private var loopEnd: AVAudioFramePosition?
    private var loopEnabled: Bool = false
    
    // Time tracking
    private var timeTrackingTask: Task<Void, Never>?
    
    var onTimeUpdate: (@Sendable (Double) -> Void)?
    
    // MARK: - Initialization
    
    init() {
        setupAudioEngine()
    }
    
    private func setupAudioEngine() {
        engine.attach(player)
        engine.attach(timePitch)
        
        engine.connect(player, to: timePitch, format: nil)
        engine.connect(timePitch, to: engine.mainMixerNode, format: nil)
        
        do {
            try engine.start()
        } catch {
            print("Failed to start audio engine: \(error)")
        }
    }
    
    // MARK: - AudioEngine Protocol
    
    func load(url: URL) async throws -> TrackMeta {
        // Stop any playback
        player.stop()
        timeTrackingTask?.cancel()
        
        // Load file
        let file = try AVAudioFile(forReading: url)
        self.audioFile = file
        
        // Calculate duration
        let sampleRate = file.processingFormat.sampleRate
        let frameCount = file.length
        let duration = Double(frameCount) / sampleRate
        self.trackDuration = duration
        
        return TrackMeta(
            name: url.deletingPathExtension().lastPathComponent,
            durationSec: duration
        )
    }
    
    func play() {
        guard let file = audioFile else { return }
        
        if !player.isPlaying {
            schedulePlayback(from: currentTimeSec())
            player.play()
            startTimeTracking()
        }
    }
    
    func pause() {
        player.pause()
        timeTrackingTask?.cancel()
        timeTrackingTask = nil
    }
    
    func seek(to timeSec: Double) {
        let wasPlaying = player.isPlaying
        player.stop()
        
        if wasPlaying {
            schedulePlayback(from: timeSec)
            player.play()
        }
    }
    
    func setRate(_ rate: Double) {
        timePitch.rate = Float(rate)
    }
    
    func setPitchSemitones(_ semitones: Double) {
        timePitch.pitch = Float(semitones * 100) // Convert to cents
    }
    
    func setLoop(aSec: Double?, bSec: Double?, enabled: Bool) {
        guard let file = audioFile else { return }
        
        let sampleRate = file.processingFormat.sampleRate
        
        if let a = aSec, let b = bSec {
            loopStart = AVAudioFramePosition(a * sampleRate)
            loopEnd = AVAudioFramePosition(b * sampleRate)
        } else {
            loopStart = nil
            loopEnd = nil
        }
        
        loopEnabled = enabled
        
        // Reschedule if playing
        if player.isPlaying {
            player.stop()
            schedulePlayback(from: currentTimeSec())
            player.play()
        }
    }
    
    func currentTimeSec() -> Double {
        guard let file = audioFile,
              let nodeTime = player.lastRenderTime,
              let playerTime = player.playerTime(forNodeTime: nodeTime) else {
            return 0
        }
        
        let sampleRate = file.processingFormat.sampleRate
        return Double(playerTime.sampleTime) / sampleRate
    }
    
    // MARK: - Private Helpers
    
    private func schedulePlayback(from timeSec: Double) {
        guard let file = audioFile else { return }
        
        let sampleRate = file.processingFormat.sampleRate
        let startFrame = AVAudioFramePosition(timeSec * sampleRate)
        
        if loopEnabled, let loopStart = loopStart, let loopEnd = loopEnd {
            // Schedule loop segment
            let frameCount = AVAudioFrameCount(loopEnd - loopStart)
            player.scheduleSegment(
                file,
                startingFrame: loopStart,
                frameCount: frameCount,
                at: nil,
                completionCallbackType: .dataPlayedBack
            ) { [weak self] _ in
                // Reschedule loop
                self?.schedulePlayback(from: timeSec)
            }
        } else {
            // Schedule from current position to end
            let frameCount = AVAudioFrameCount(file.length - startFrame)
            player.scheduleSegment(
                file,
                startingFrame: startFrame,
                frameCount: frameCount,
                at: nil
            )
        }
    }
    
    private func startTimeTracking() {
        timeTrackingTask?.cancel()
        
        timeTrackingTask = Task { [weak self] in
            while !Task.isCancelled {
                guard let self = self else { return }
                
                let currentTime = self.currentTimeSec()
                self.onTimeUpdate?(currentTime)
                
                try? await Task.sleep(for: .milliseconds(33)) // ~30fps
            }
        }
    }
}
```

### WaveformPeakComputer

```swift
// Engine/WaveformPeakComputer.swift
import AVFoundation
import Accelerate

struct WaveformPeaks: Sendable {
    let min: [Float]
    let max: [Float]
    let buckets: Int
    let durationSec: Double
}

final class WaveformPeakComputer: Sendable {
    func computePeaks(url: URL, targetBuckets: Int) async throws -> WaveformPeaks {
        // Use Task.detached to avoid blocking main actor
        try await Task.detached {
            let file = try AVAudioFile(forReading: url)
            let format = file.processingFormat
            let frameCount = AVAudioFrameCount(file.length)
            
            guard let buffer = AVAudioPCMBuffer(
                pcmFormat: format,
                frameCapacity: frameCount
            ) else {
                throw WaveformError.bufferCreationFailed
            }
            
            try file.read(into: buffer)
            
            // Compute peaks using vDSP
            // ... implementation details ...
            
            return WaveformPeaks(
                min: minPeaks,
                max: maxPeaks,
                buckets: targetBuckets,
                durationSec: Double(frameCount) / format.sampleRate
            )
        }.value
    }
}

enum WaveformError: Error {
    case bufferCreationFailed
}
```

---

## Layer 3: AppGlue (Store / Runtime)

### What Lives Here

**The bridge between pure domain logic and impure services.**

- ✅ `Core` class (the "Store" that owns Model + runs Commands)
- ✅ `@Observable @MainActor` for SwiftUI integration
- ✅ `EffectRunner` to execute Commands via services
- ✅ `Dependencies` struct for dependency injection

### File Structure

```
AppGlue/
├── Core.swift              # Observable store
├── EffectRunner.swift      # Command executor
└── Dependencies.swift      # DI container
```

### Core (The Store)

```swift
// AppGlue/Core.swift
import SwiftUI
import Observation

@Observable
@MainActor
final class Core {
    // MARK: - State
    
    /// The single source of truth
    var model: PlayerModel
    
    // MARK: - Private Dependencies
    
    private let runner: EffectRunner
    private let deps: Dependencies
    
    // MARK: - Initialization
    
    init(deps: Dependencies) {
        self.model = PlayerModel()
        self.deps = deps
        self.runner = EffectRunner(deps: deps)
        
        // Wire up engine callbacks
        deps.engine.onTimeUpdate = { [weak self] time in
            Task { @MainActor in
                self?.send(.tick(currentTimeSec: time))
            }
        }
    }
    
    // MARK: - Public API
    
    /// Send a message to update state and trigger side effects
    func send(_ msg: Msg) {
        // Call pure update function
        let commands = Update.update(
            model: &model,
            msg: msg,
            now: deps.now
        )
        
        // Execute commands via runner
        for command in commands {
            runner.run(command, core: self)
        }
    }
}
```

### EffectRunner

```swift
// AppGlue/EffectRunner.swift
import Foundation

@MainActor
final class EffectRunner {
    private let deps: Dependencies
    
    init(deps: Dependencies) {
        self.deps = deps
    }
    
    func run(_ command: Command, core: Core) {
        switch command {
        case .engineLoad(let url):
            Task {
                do {
                    let track = try await deps.engine.load(url: url)
                    core.send(.importSucceeded(track: track))
                } catch {
                    core.send(.importFailed(message: "Unable to open file"))
                }
            }
            
        case .enginePlay(let fromTimeSec):
            deps.engine.seek(to: fromTimeSec)
            deps.engine.play()
            
        case .enginePause:
            deps.engine.pause()
            
        case .engineSeek(let timeSec):
            deps.engine.seek(to: timeSec)
            
        case .engineSetRate(let rate):
            deps.engine.setRate(rate)
            
        case .engineSetPitchSemitones(let semitones):
            deps.engine.setPitchSemitones(semitones)
            
        case .engineSetLoop(let aSec, let bSec, let enabled):
            deps.engine.setLoop(aSec: aSec, bSec: bSec, enabled: enabled)
            
        case .computePeaks(let url, let targetBuckets):
            Task {
                do {
                    let peaks = try await deps.peakComputer.computePeaks(
                        url: url,
                        targetBuckets: targetBuckets
                    )
                    // Store peaks in AppGlue cache (not in Domain model)
                    // Views can access via Core
                } catch {
                    print("Failed to compute peaks: \(error)")
                }
            }
            
        case .startTimeTracking:
            // Time tracking is handled by engine's onTimeUpdate callback
            break
            
        case .stopTimeTracking:
            // Handled by engine when paused
            break
        }
    }
}
```

### Dependencies

```swift
// AppGlue/Dependencies.swift
import Foundation

struct Dependencies {
    let engine: AudioEngine
    let peakComputer: WaveformPeakComputer
    let now: @Sendable () -> Date
    
    static var live: Dependencies {
        Dependencies(
            engine: DefaultAudioEngine(),
            peakComputer: WaveformPeakComputer(),
            now: Date.init
        )
    }
    
    static var test: Dependencies {
        Dependencies(
            engine: MockAudioEngine(),
            peakComputer: MockPeakComputer(),
            now: { Date(timeIntervalSince1970: 0) }
        )
    }
}
```

---

## Layer 4: UI (SwiftUI Views)

### What Lives Here

**Presentation layer that observes state and sends messages.**

- ✅ SwiftUI views
- ✅ Geometry calculations (coordinate → time mapping)
- ✅ Layout and styling
- ✅ Gesture recognition

**NEVER:**
- ❌ Business logic
- ❌ Direct state mutation
- ❌ AVFoundation imports
- ❌ Side effects (use `core.send(msg)` instead)

### Pattern

```swift
// UI/PlayerView.swift
import SwiftUI

struct PlayerView: View {
    @Bindable var core: Core
    
    var body: some View {
        VStack(spacing: 0) {
            // Read state
            if let track = core.model.track {
                TrackRow(trackName: track.name)
                WaveformView(core: core)
                TransportBar(core: core)
            } else {
                EmptyStateView(core: core)
            }
        }
    }
}

struct TransportBar: View {
    @Bindable var core: Core
    
    var body: some View {
        HStack {
            // Speed controls
            Button("-") {
                core.send(.speedDelta(-0.05))
            }
            
            Text(Formatting.formatSpeed(core.model.transport.speed))
            
            Button("+") {
                core.send(.speedDelta(0.05))
            }
            
            Spacer()
            
            // Play/pause
            Button(core.model.transport.isPlaying ? "Pause" : "Play") {
                core.send(.togglePlay)
            }
        }
        .padding()
    }
}

struct WaveformView: View {
    @Bindable var core: Core
    
    var body: some View {
        Canvas { context, size in
            // Draw waveform
            drawWaveform(context: context, size: size)
        }
        .gesture(
            DragGesture(minimumDistance: 0)
                .onChanged { value in
                    // ✅ Only geometry calculation in UI
                    let timeSec = xToTime(
                        x: value.location.x,
                        width: size.width,
                        viewport: core.model.viewport
                    )
                    core.send(.dragScrub(timeSec: timeSec))
                }
        )
    }
    
    // ✅ Pure coordinate transformation (allowed in UI)
    private func xToTime(x: CGFloat, width: CGFloat, viewport: Viewport) -> Double {
        let ratio = x / width
        return viewport.startSec + ratio * (viewport.endSec - viewport.startSec)
    }
}
```

---

## Key Architectural Rules

### 1. Data Flow (Unidirectional)

```
User Action → UI sends Msg → Core.send() → Update.update() → (new Model, [Command])
                                   ↓                                    ↓
                              Model updated                    EffectRunner.run()
                                   ↓                                    ↓
                              UI re-renders ←─────────────── Engine callbacks
```

### 2. Where Things Live

| Concept | Type | Layer | Example |
|---------|------|-------|---------|
| State | `struct` | Domain | `PlayerModel`, `Transport` |
| Events | `enum` | Domain | `Msg.togglePlay`, `Msg.tick` |
| Side effects | `enum` | Domain | `Command.enginePlay` |
| Business logic | `func` | Domain | `Update.update()` |
| Derived state | `func` | Domain | `Selectors.loopRange()` |
| Formatters | `func` | Domain | `Formatting.formatTime()` |
| Service boundary | `protocol` | Engine | `AudioEngine` |
| Side effect impl | `class` | Engine | `DefaultAudioEngine` |
| Store | `class` | AppGlue | `Core` |
| Command executor | `class` | AppGlue | `EffectRunner` |
| Presentation | `struct` | UI | `PlayerView`, `TransportBar` |

### 3. Import Rules

| Layer | May Import | NEVER Import |
|-------|------------|--------------|
| Domain | `Foundation` | `SwiftUI`, `AVFoundation`, `UIKit` |
| Engine | `AVFoundation`, `Accelerate`, `Foundation` | `SwiftUI` |
| AppGlue | `Domain`, `Engine`, `SwiftUI`, `Observation` | Direct AVFoundation usage |
| UI | `SwiftUI`, `AppGlue` | `AVFoundation`, Domain internals |

### 4. Testing Strategy

```swift
// ✅ Test pure update function (easy, fast, reliable)
@Test("Toggle play starts playback when paused")
func testTogglePlay() {
    var model = PlayerModel()
    model.transport.isPlaying = false
    
    let commands = Update.update(model: &model, msg: .togglePlay)
    
    #expect(model.transport.isPlaying == true)
    #expect(commands.contains(.enginePlay(fromTimeSec: 0)))
}

// ✅ Test selectors (pure functions)
@Test("Loop range normalizes A and B")
func testLoopRange() {
    var model = PlayerModel()
    model.loop.aSec = 10.0
    model.loop.bSec = 5.0
    
    let range = Selectors.loopRange(model)
    
    #expect(range?.0 == 5.0)
    #expect(range?.1 == 10.0)
}

// ✅ Test formatters (pure functions)
@Test("Format time as MM:SS.xx")
func testFormatTime() {
    let formatted = Formatting.formatTime(125.5)
    #expect(formatted == "02:05.50")
}
```

### 5. Prohibited Patterns

```swift
// ❌ NEVER: Business logic in UI
struct WaveformView: View {
    var body: some View {
        // ❌ DON'T calculate loop points here
        let loopStart = min(pointA, pointB)  // Belongs in Domain
    }
}

// ❌ NEVER: Side effects in Domain
enum Update {
    static func update(model: inout PlayerModel, msg: Msg) -> [Command] {
        case .importPicked(let url):
            let file = try AVAudioFile(forReading: url)  // ❌ Side effect!
    }
}

// ❌ NEVER: Direct state mutation in UI
Button("Play") {
    core.model.transport.isPlaying = true  // ❌ Use core.send(.togglePlay)
}

// ❌ NEVER: SwiftUI in Domain
// Domain/Models/PlayerModel.swift
import SwiftUI  // ❌ FORBIDDEN

// ❌ NEVER: AVFoundation in UI
// UI/WaveformView.swift
import AVFoundation  // ❌ FORBIDDEN
```

---

## Benefits of This Architecture

### 1. Testability
- Pure `update()` function is trivial to test
- No mocking needed for business logic
- Fast, reliable unit tests

### 2. Predictability
- All state changes go through `update()`
- Easy to trace what happened and why
- Time-travel debugging possible

### 3. Separation of Concerns
- Domain: "What should happen?"
- Engine: "How to do it?"
- AppGlue: "Wire it together"
- UI: "Show it"

### 4. Future-Proof
- Engine is protocol-based
- Can swap AVFoundation for Rust/Crux later
- Domain logic remains unchanged

### 5. Maintainability
- Clear boundaries
- Easy to find where logic lives
- Changes are localized

---

## Migration Path (Future: Rust/Crux)

When ready to move to Rust core:

1. **Domain layer** → Rust (already pure functions, easy to port)
2. **Engine protocol** → Keep as Swift boundary
3. **Rust implementation** → Implement `AudioEngine` protocol
4. **AppGlue** → Minimal changes (just swap engine implementation)
5. **UI** → No changes needed

The architecture is designed for this transition.

---

**Last Updated:** December 26, 2025
**Purpose:** Define Elm-inspired functional architecture for Sharp9 iOS app
