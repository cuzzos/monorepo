---
description: Elm-inspired architecture - pure functional core with impure shell
globs:
  - "**/*.swift"
alwaysApply: true
---

# Sharp9 Architecture

**Full spec:** See `docs/ARCHITECTURE.md`

## Core Principle

**Pure functional core, impure shell.** Business logic in pure functions. Side effects isolated in protocol-based services.

## Layer Structure

```
UI (SwiftUI) → AppGlue (Store) → Domain (Pure) + Engine (Impure)
```

| Layer | Purpose | May Import | NEVER Import |
|-------|---------|------------|--------------|
| **Domain** | Pure state + logic | `Foundation` | `SwiftUI`, `AVFoundation` |
| **Engine** | Side effects (audio) | `AVFoundation`, `Accelerate` | `SwiftUI` |
| **AppGlue** | Wires domain + engine | `Domain`, `Engine`, `SwiftUI` | Direct AVFoundation |
| **UI** | Renders state, sends msgs | `SwiftUI`, `AppGlue` | `AVFoundation`, Domain internals |

## Where Things Live

| Concept | Location | Type |
|---------|----------|------|
| App state | `Domain/Models/` | `struct` |
| User events | `Domain/Actions/Action.swift` | `enum Action` |
| Side effect descriptions | `Domain/Actions/Effect.swift` | `enum Effect` |
| Business logic | `Domain/Logic/Reducer.swift` | Pure `reduce()` function |
| Derived state | `Domain/Logic/Selectors.swift` | Pure functions |
| Audio playback | `Engine/` | Protocol + class |
| Store (owns state) | `AppGlue/Core.swift` | `@Observable` class |
| Effect execution | `AppGlue/EffectRunner.swift` | Runs effects via Engine |

## Data Flow

```
User taps → UI calls core.send(action) → Reducer.reduce() → (new state, [Effect])
                                                ↓                    ↓
                                         State updated       EffectRunner executes
                                                ↓                    ↓
                                         UI re-renders ←── Engine callbacks
```

## Key Rules

### Domain Layer (Pure)
- ✅ `struct` models only (Sendable)
- ✅ `enum` for actions and effects
- ✅ Pure `reduce(state, action) -> (state, [Effect])`
- ❌ NO classes, NO async, NO side effects

### Engine Layer (Impure)
- ✅ Protocol defines boundary (`AudioEngine`)
- ✅ Class implements with AVFoundation
- ❌ NO business logic, NO SwiftUI

### UI Layer
- ✅ Observe state via `@Bindable var core: Core`
- ✅ Send actions via `core.send(.action)`
- ❌ NO direct state mutation
- ❌ NO business logic (use Selectors)

## Testing

Test pure functions only - no mocking needed:

```swift
@Test("Toggle play starts playback")
func testTogglePlay() {
    var state = AppState()
    let effects = Reducer.reduce(state: &state, action: .togglePlay)
    #expect(state.transport.isPlaying)
}
```
